/*!
 * This library contains the required structs and macros to create your own Scout Plugins.
 * Here is a quick guide to creating your own plugins:
 *
 * Create a new library crate, and make sure you define the following keys and add this crate as a dependency.
 *
 * ```toml
 * [lib]
 * crate-type = [ "cdylib" ]
 * ```
 *
 * Now, define your plugin struct in lib.rs. Make sure you implement the Plugin trait in this crate.
 *
 * ```rust
 * pub struct MyPlugin;
 *
 * impl scout_core::Plugin for MyPlugin {
 *   ...
 * }
 * ```
 *
 * Finally, add the following code to the bottom of your lib.rs to export the plugin.
 *
 * ```rust
 * #[allow(improper_ctypes_definitions)]
 * extern "C" fn register(registrar: &mut dyn scout_core::PluginRegistrar) {
 *   registrar.register("my_plugin", Box::new(MyPlugin));
 * }
 *
 * scout_core::export_plugin!(register);
 * ```
 *
 * That's it! Now your plugin can be built using `cargo build --all`, and the resultant .so can be loaded by Scout.
 */

/** The current core scout_core version. */
pub static CORE_VERSION: &str = env!("CARGO_PKG_VERSION");


/** The current Rust compiler version. */
pub static RUSTC_VERSION: &str = env!("RUSTC_VERSION");


/** A plugin declaration, generated by the export_plugin macro. */
pub struct PluginDeclaration {
	pub rustc_version: &'static str,
	pub core_version: &'static str,
	pub register: unsafe extern "C" fn(&mut dyn PluginRegistrar),
}


/** Passed into a library to allow it to register plugins. */
pub trait PluginRegistrar {
	fn register(&mut self, name: &str, function: Box<dyn Plugin>);
}

 
/** Exports a plugin for Scout to use. See the module documentation for usage details. */
#[macro_export]
macro_rules! export_plugin {
	($register: expr) => {
		#[doc(hidden)]
		#[no_mangle]
		pub static PLUGIN_DECLARATION: $crate::PluginDeclaration = $crate::PluginDeclaration {
			rustc_version: $crate::RUSTC_VERSION,
			core_version: $crate::CORE_VERSION,
			register: $register,
		};
	};
}


/** Trait methods for plugins. */
pub trait Plugin {
	fn call(&self, args: &[f64]) -> Result<f64, InvocationError>;
}


/** Represents an error in invoking a plugin. */
#[derive(Debug)]
pub enum InvocationError {
	InvalidArgumentCount { expected: usize, found: usize },
	Other { msg: String }
}

impl<S: ToString> From<S> for InvocationError {
	fn from(other: S) -> InvocationError {
		InvocationError::Other {
			msg: other.to_string(),
		}
	}
}
